Repast Simphony Documentation
=============================
Version 2.5 October 2017
:toc:
:icons:
:numbered:
:website: http://repast.github.io

Introduction
------------

About Repast Simphony
~~~~~~~~~~~~~~~~~~~~~

.TODO
****
Needs updating
****

Installation
~~~~~~~~~~~~

.TODO
****
Needs updating
****

Project Configuration
---------------------

Creating a New Repast Project
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.TODO
****
Needs updating
****

Updating an Existing Repast Project
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.TODO
****
Needs updating
****

Adding Repast to an Existing Project
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.TODO
****
Needs updating
****

If you have an existing Java project in which you would like to reference Repast classes, you can right
click on the project and select Repast Simphony -> Add Repast Simphony to this Project.
This will add the Repast libraries to the project class path so that you can reference Repast classes and
run simulations from your project without needing to manually add all of the Repast libraries and
dependencies.

Model Configuration Files
~~~~~~~~~~~~~~~~~~~~~~~~~
.TODO
****
Needs updating
****

.user_path.xml

----
<model name="Model Name">
	<classpath>
		<entry path="..." annotations="[true|false]" />
		<agents path="..." filter="..." />
		<builtin fullname="..." />
	</classpath>
</model>
----

* path is path statement to a directory or jar file. If the directory contains jars then all those jars are
added to the classpath. If the directory or its children contain .class files then the directory is added
to the classpath. More than one path can be specified. Multiple paths should be "," separated. For
.class files, the path functions as a classpath and so it must be the directory immediately above the
directories corresponding to the class packages. For example, given the class
repast.simphony.MyClass and the directory structure X/bin/repast/simphony/MyClass.class, the path
should be X/bin. This applies to path in both entry and agents elements.

* annotations specified whether or not any classes found in the specified path(s) should be processed
for annotations. The default is false.

* agents specifies the path where agent classes can be found. These are automatically processed for
annotations.

* filter specifies a class filter on the agents path(s). For example a filter of "anl.gov.Agent" will filter
out all classes but anl.gov.Agent as agent classes. Filters can contain the wildcard "*". So for
example, "anl.gov.*Agent" will include any class in the package anl.gov whose class name ends with
Agent.

* the builtin element is for the case when a user needs to add an agent class existing in one of the
repast plugins. The user specifies the canonical class name as the fullname.

NOTE: For the builtins, since the class can be in any one of the repast plugins, without hard coding the
path, it is difficult to use the filter mechanism on all the plugins. This means that unless we can figure out
a way to figure out the path of a resource containing a package, we must specify each individual class
that we'd like to be considered an agent class. The good news is that this is not a common usage.

.context.xml
context.xml contains the context heirarchy information.

----
<context id="..." class="...">
	<attribute id="..." value="..." type="[int|long|double|float|boolean|string|...]"
		display_name="..." converter="..."/>
	<projection id="..." type="[network|grid|continuous space|geography|value layer]">
		<attribute id="..." .../>
	</projection>

	<context id="..." class="...">
		...
	</context>
</context>
----

.Context Element
[options="header",width="60%",cols="3"]
|====
|Attribute Name |Description |Required
|id |Unique identifer for the context |YES
|class |Fully qualitifed name of a Context implementation. If this
is present this context will be used instead of the default |NO
|====

.Attribute Element
[options="header",width="60%",cols="3"]
|====
|Attribute Name |Description |Required
|id |Unique identifer for the attribute |YES
|value |Default value of the attribute |YES
|type |The primitive or class type of the attribute |YES
|display_name |Optional name used to display the attribute when it is used as a model parameter |NO
|converter |Optional implementation of StringConverter used to convert the attribute to and from a string representation |NO
|====

For example:
----
<context id="MyContext">
	<attribute id="numAgents" value="20" type="int" display_name="Initial Number of Agents"/>
</context>
----

.Projection Element
[options="header",width="60%",cols="3"]
|====
|Attribute Name |Description |Required
|id |Unique identifer for the projection |YES
|type |The projection type (network, grid, geography, continuous space, value layer) |YES
|====

.Special Attributes
If certain special attributes are present, then the context.xml file can be used to instantiate the actual
context hierarchy. The attributes are defined in the repast.simphony.dataLoader.engine.AutoBuilderConstants.


.Context Attributes
[options="header",width="60%",cols="5"]
|====
|Attribute Id |Description |Allowed values |type |Required
|\_timeUnits_ |The tick unit type |Any string that can be parsed by Amount.valueOf |string |NO
|====

.Grid Attributes
[options="header",width="60%",cols="5"]
|====
|Attribute Id |Description |Allowed values |type |Required
|Any attribute of int type |Any int attributes
will be used as the dimensions of the
grid. These will be processed in order
such that the first becomes the width
(x) dimensions, the next the height
(y) and so on. |Any int |int |YES
|border rule |Specifies the behavior of agents
when moving over a grid's borders. |bouncy, sticky, strict, or periodic |string |YES
|allows multi |whether or not the grid allows multiple agents in
each cell |true or false (default is false) |boolean |NO
|====

For example:
----
<context id="MyContext">
	<projection id="MyGrid" type="grid">
		<attribute id="width" type="int" value="200"/>
		<attribute id="height" type="int" value="100"/>
		<attribute id="border rule" type="string" value="periodic" />
		<attribute id="allows multi" type="boolean" value="true"/>
	</projection>
</context>
----
will create a 200x100 grid with an id of "MyGrid." The border rule for the grid is "periodic" so the grid
will wrap, forming a torus. The grid will also allow multiple agents in each cell.

.Continuous Space Attributes
[options="header",width="60%",cols="5"]
|====
|Attribute Id |Description |Allowed values |type |Required
|Any attribute of int or double type | Any int or double
attributes will be used as the dimensions of the grid. These will be
processed in order such that the first becomes the width (x) dimensions,
the next the height (y) and so on. |Any int or double |int or double |YES
|border rule |Specifies the behavior of agents when moving over
a space's borders. |bouncy, sticky, strict, or periodic |string |YES
|====

For example:
----
<context id="MyContext">
	<projection id="MySpace" type="continuous space">
		<attribute id="width" type="int" value="200"/>
		<attribute id="height" type="int" value="100"/>
		<attribute id="border rule" type="string" value="strict" />
	</projection>
</context>
-----
will create a 200x100 continuous space with an id of "MySpce." The border rule for the grid is "strict"
so any movement across the border will cause an error.

.Network Attributes
[options="header",width="60%",cols="5"]
|====
|Attribute Id |Description |Allowed values |type |Required
|directed |Whether or not the network is directed |true or false. Default is false |boolean |NO
|edge class |The fully qualified name of a class that 
extends RepastEdge. Any edges created by the network will be
of this type. |Any properly formatted class name extending RepastEdge |string |NO
|====

For example:
----
<context id="MyContext">
	<projection id="MyNetwork" type="network">
		<attribute id="directed" type="boolean" value="true"/>
	</projection>
</context>
----
will create a network with an id of "MyNetwork." The network will be directed and use the default
RepastEdge as the edge type.

Distributing Your Model
~~~~~~~~~~~~~~~~~~~~~~~
.TODO
****
Needs updating
****

Models created with Repast Simphony may easily be distributed with the provided Install Builder tool.
This tool builds a distributable installer that anyone may use to install the model to their computer. The
only requirement for those to who the model is distributed is the target system to have a current Java
Runtime Environment (version 5 or later).

To start the Install Builder, select Build Installer in the run menu

The builder make take a few minutes to complete the installer. Once this process is complete, a
message BUILD SUCCESSFUL should be visible in the Console window.

Repast Model Design Fundamental Concepts
----------------------------------------
.TODO
****
This was probably copied from one of our papers, but maybe there is a nicer version.
****

Contexts
~~~~~~~~
The Context is the core concept and object in Repast Simphony. It provides a data structure to organize
your agents from both a modelling perspective as well as a software perspective. Fundamentally, a
context is just a bucket full of agents, but they provide more richness.

Contexts are hierarchically nested named containers that hold model components. The model
components can be any type of POJO, including other contexts, but are often expected to be agent
objects. Each model component can be present in as many contexts as the modeler desires. The
hierarchical nesting means that a model component that is present in a context is also present in all of
that context's parent contexts. Of course, the converse is not true in the general case. The hierarchical
nesting structure itself can be declaratively or imperatively specified by the modeler. Context
membership and structure is completely dynamic and agents can be in any number or combination of
contexts at any time. Furthermore, agents can themselves contain any number of contexts and even be
contexts. In addition, the contents of components within contexts (e.g., agent properties) can be
declaratively logged at runtime.

In addition to supporting hierarchical nesting, contexts support projections. Repast projections are
named sets of relationships defined over the members of a context. For example, a Repast S network
projection stores a network or graph relationship between the members of its context. The members of
this context can then ask who they are linked to and who is linked to them. Similarly, the Repast S grid
projection stores a set of Cartesian coordinates for each member of the context. The members of this
context can ask where they are. For more details on projections, see Details on Projections. Each context
can support any mixture of projections. Also, projections can be declaratively visualized at runtime.
Contexts also support data layers. Data layers represent numerical data that can be accessed using a set
of coordinates. Data layers allow model designers to provide numerical values with which their agents
can interact. The data layers for a given context are separate from the layers for other contexts, allowing
the agents to orient themselves with respect to a set of data depending on which context they are using.
Within a context, data layers can be connected to:

* a particular projection (e.g., each cell in a two-dimensional grid may have some data associated
with it),

* multiple projections (e.g., a value at a particular set of coordinates might depend on both a grid and
a set of network relations), or

* no projections (e.g., the data is stored in an abstract matrix).

Projections
~~~~~~~~~~~
While Contexts create a bucket to hold your agents, Projections impose a structure upon those agents.
Simply using Contexts, you could never write a model that provided more than a simple "soup" for the
agents. The only way to grab other agents would be randomly. Projections allow you to create a
structure that defines relationships, whether they be spatial, network, or something else. A projection os
attached to a particular Context and applies to all of the agents in that Context. This raises an important
point. An object must exist in a Context before it can be used in a projection. So, if you try to work with
an agent in a projection before you have added it to the Context, it will fail. For example, if you have a
network, and you try to create a link between agents where at least one of the agents does not yet exist
in the context, then the operation will fail. This is to maintain the integrity of the context which is used in
many place throughout the repast system.

You can apply as many projections to a context as you want, so you could have a context that contains, a
grid, a gis space and 4 networks if you felt so inclined. This provides a great deal of flexibility to design
your model.

Your agents can get a reference to various projections through their enclosing context. An agent could
do the following where "this" refers to the agent:

----
Context context = ContextUtils.getContext (this)
Projection projection = context.getProjection("friendshipNetwork");
----

That projection wouldn't be that useful unless you cast the projection to something more specific. You
could also do it like this:

----
Context context = ContextUtils.getContext(this);
Network network = context.getProjection(Network.class, "friendshipNetwork");
----

Creating Projections
~~~~~~~~~~~~~~~~~~~~
In general, projections are created using a factory mechanism in the following way.

. Find the factory

. Use the factory to create the projection

.TODO
****
Use complete examples or merge with the following sections
****

----
Context<SimpleHappyAgent> context = Contexts.createContext(SimpleHappyAgent.class, "my context");
GridFactory factory = GridFactoryFinder.createGridFactory(new HashMap());
Grid grid = factory.createGrid("Simple Grid", context, ...);
Context<SimpleHappyAgent> context = Contexts.createContext(SimpleHappyAgent.class, "mycontext");
----

----
ContinuousSpaceFactory factory = ContinuousSpaceFactoryFinder.createContinuousSpaceFactory(new HashMap());
ContinuousSpace space = factory.createContinuousSpace("Simple Space", context, ...);
----

Each factory creates a projection of a specific type and requires the context that the projection is
associated with and the projections name as well as additional arguments particular to the projection
type. These additional arguments are marked above with "..." and are explicated on the individual pages
for that projection.

Continuous Space Projection
~~~~~~~~~~~~~~~~~~~~~~~~~~~
A continuous (real valued) space projection is a space in which an agents location is represented by
floating point coordinates. For example, one agent may be at the point 2.133, 0 and another may be at
21.1, 234. This contrasts with the discrete integer valued grid projections. However, much of the
behavior of a continuous space like that of the grid, so it maybe worthwhile reading those Grid
Projections pages first.

Repast Simphony provides a rich set of tools to work with grids of all kinds. Specifically, it supports

* 1D, 2D, 3D and ND continuous spaces,

* Toroidal, Reflective and Fixed Border conditions.

Random Numbers
~~~~~~~~~~~~~~

.RandomRegistry
Like many of the other registries in Simphony, the RandomRegistry is available through the current
RunState (through its getRandomRegistry() method). This interface provides the capability for storing
named random distributions and retrieving them. It also can set and retrieve the seed that a stream will
use (or is using) for streams it creates through its addStream(String, Class, ...) methods.

.RandomHelper
The RandomRegistry by itself is somewhat difficult to work with, to simplify using it the RandomHelper
class was created. This provides methods for creating the random streams that will be used, and for
retrieving the streams after they have been created, when you do not have a reference to the current
RunState.

Through its getStream, getUniform and getNormal methods, you can retrieve distributions from the
current RandomRegistry. Through its numerous createXXX methods, you can create the distributions and
store them to the current RandomRegistry.

The RandomHelper also handles creating and maintaining a default Uniform number stream. This stream
is the one used by Repast when it needs a random number, and is no different then the other Uniform
number streams, except that it will always exist when requested from the RandomHelper (when the
simulation is running). If you wish to use a Uniform distribution for your random numbers, you can avoid
some of the extra work that comes with the named streams (meaning, specifying the name of the
stream, and possibly casting the stream) by simply using RandomHelpers' getDefault, nextInt, and
nextDouble methods. You also can retrieve and/or set the seed for the default stream through the
RandomHelper's getSeed and setSeed methods.

Generally there are going to be two types of usage of the random functionality. The first would be when
you just need random numbers of some sort. In this case you would just want to use RandomHelper's
default methods, meaning the getDefault(), nextInt and nextDouble methods.

The other case is when you want numbers from a non-Uniform distribution, or you want multiple random
streams functioning at once. In this case you can use RandomHelper's default methods for any uniform
numbers, but for producing multiple streams or a non-Uniform stream you have to use the methods that
take in a stream name. Each of these separate cases will be walked through next.

.Single Stream Default Use
When working with the default Uniform stream there is really only one thing you may want to look at
manipulating, the default stream's random seed. This is set through the RandomHelper's setSeed(int)
method. Setting the random seed should generally happen when the model is setting up. There are two
ways you can do this. One way is in a ControllerAction, but if you wish to use the random numbers in
setting up the model you will not have your seed set ahead of time. The other (correct) way is in a
ParameterSetter.

In the ParameterSetter you are going to want to call RandomHelper's setSeed method, as below:

----
public class MySimpleSetter extends SimpleParameterSetter {
	public void next(Parameters params) {
		RandomHelper.setSeed(System.currentTimeMillis());
	}
}
----

The above code will set the default uniform distribution's seed to be the current time. Now that the time
is set, the agents or controller actions (in their runInitialize methods) can use the default distribution and
will recieve numbers based off of that seed. For example if you had an agent that wanted to move based
on some random condition, that could look like:

----
public void agentAction() {
	if (myHappiness < RandomHelper.nextDouble()) {
		move();
	}
}
----

The above example compares the agent's happiness to a random number between 0 and 1, in (0, 1), if
the random number is greater than the agent's happiness it will move.

.Multiple Stream / Non Uniform Stream Usage
As with the single streams, you generally are going to want to create your Random number streams
when your model is initializing, primarily in a ParameterSetter, at the point the ParameterSetter will be
executed the run's RandomRegistry will be setup, and you can feel free to use the RandomHelper.

With these streams you are going to need to consistently use the same stream name(s) when working
with the RandomHelper or the RandomRegistry. You will need to pass this name into the methods, so
that that the helper/registry knows where to get the values from. For example, let's say that you want 2
random number streams; one a Poisson distribution, and one a Normal distribution. With both of these
using a distinct random seed.

So an example initialization would look like:

----
public class MySetter extends ParameterSetter {
	public void next(Parameters params) {
		// first create the normal distribution
		// we pass in null so that it will use the current random registry
		RandomHelper.createNormal(null, "MyNormal", normalSeed, 0, 1);
		// next we create the poisson distribution

		RandomHelper.createPoisson(null, "MyPoisson", poissonSeed, 0);
	}
}
----

The above code created a normal distribution named "MyNormal" that has a mean of 0, a standard
deviation of 1, and some seed (normalSeed). It then creates a poisson distribution named "MyPoisson"
with a mean of 0 and some specified seed (poissonSeed). It is worth noticing however that unlike the
default stream, if you do not setup these streams with the given name they will not be created for you.
You must create them in some way (for instance like above) or you will not be able to use them.

You can then use these distributions from your code. If you wanted to do the same thing as the single
stream example, but with the normal stream you would do:

----
public void agentAction() {
	if (myHappiness < RandomHelper.getNormal("MyNormal").nextDouble()) {
		move();
	}
}
----

The Poisson stream is slightly less straighforward to use, in that direct helper methods are not provided
that will cast the stream to a Poisson distribution. For this distribution you must cast the stream
yourself. This is more complicated than it sounds, and functions simply like:

----
public void agentAction() {
	// grab the distribution with the given name, casting it to a Poisson distribution
	Poisson randomStream = (Poisson) RandomHelper.getStream("MyPoisson");
	// now use it
	if (myHappiness < randomStream.nextDouble()) {
		move();
	}
}
----

Scheduling
~~~~~~~~~~
There are basically three ways to work with the Repast Simphony Scheduler. No one is better than the
other and they each have their specified purpose.

.Directly Schedule an action
This is similar to the way that actions have always been scheduled in repast with a slight twist. In this
scenario, you get a schedule and tell it the when and what to run. An example of adding an item to the
schedule this way is as follows:

----
//Specify that the action should start at tick 1 and execute every other tick
ScheduleParameters params = ScheduleParameters.createRepeating(1, 2);
//Schedule my agent to execute the move method given the specified schedule parameters.&nbsp;
schedule.schedule(params, myAgent, "move");
----

The biggest change here is that instead of using one of the numerous methods to set up the parameters
for the action like you would in repast 3, you just use an instance of ScheduleParameters.
ScheduleParameters can be created using one of several convient factory methods if desired. A slight
alteration of this is:

----
//Specify that the action should start at tick 1 and execute every other tick
ScheduleParameters params = ScheduleParameters.createRepeating(1, 2);
//Schedule my agent to execute the move method given the specified schedule parameters.
schedule.schedule(params, myAgent, "move", "Forward", 4);
----

This example schedules the same action with the same parameters, but passes arguments to the method
that is to be called. The "Forward" and 4 will be passed as arguments to the method move. The
assumption is that the signature for move looks like this:

----
public void move(String direction, int distance)
----

.Schedule with Annotations
Java 5 introduced several new and exciting features (some of which are used above), but one of the
most useful is Annotation support. Annotations, in java, are bits of metadata which can be attached to
classes, methods or fields that are available at runtime to give the system more information. Notable
uses outside repast includes the EJB3 spec which allows you to create ejbs using annotations without
requiring such complex descriptors. For repast, we thought annotations were a perfect match for tying
certain types of scheduling information to the methods that should be scheduled. The typical case where
you would use annotations is where you have actions whose schedule is know at compile time. So for
example, if you know that you want to have the paper delivered every morning, it would be logical to
schedule the deliverPaper() method using annotations. Without going into extensive documentation
about how annotations work (if you want that look at Java 5 Annotations), here is how you would
schedule an action using annotations:

----
@ScheduledMethod(start=1 , interval=2)
public void deliverPaper()
----

The arguments of the annotation are similar to the properties for the ScheduleParameters object. One
particularly nice feature of using annotations for scheduling is that you get keep the schedule information
right next to the method that is scheduled, so it is easy to keep track of what is executing when.
Most of the time, objects with annotations will automatically be added to the schedule, however, if you
create a new object while your simulation is running, this may not be the case. Fortunately, the schedule
object makes it very easy to schedule objects with annoations.

----
//Add the annotated methods from the agent to the schedule.
schedule.schedule(myAgent);
----

The schedule will search the object for any methods which have annotations and add those methods to
the schedule. This type of scheduling is not designed to handle dynamic scheduling, but only scheduling, where the
actions are well defined at compile time.

.Schedule with Watcher
Scheduling using watchers is the most radical of the new scheduling approaches. Watchers are designed
to be used for dynamic scheduling where a typical workflow is well understood by the model designer.
Basically, a watcher allows an agent to be notified of a state change in another agent and schedule an
event to occur as a result. The watcher is set up using an annotation (like above), but instead of using
static times for the schedule parameters, the user specifies a query defining whom to watch and a query
defining a trigger condition that must be met to execute the action. That's a bit of a mouthfull, so let's
take a look at an example to hopefully clarify how this works. (this code is from the SimpleHappyAgent
model which ships with Repast Simphony)

----
@Watch(watcheeClassName = "repast.demo.simple.SimpleHappyAgent", watcheeFieldName =
	"happiness", query = "linked_from",
	whenToTrigger = WatcherTriggerSchedule.LATER, scheduleTriggerDelta = 1,
	scheduleTriggerPriority = 0)
public void friendChanged(SimpleHappyAgent friend) {
	if (Math.random() > .25) {
	this.setHappiness(friend.getHappiness());
	} else {
		this.setHappiness(Random.uniform.nextDouble());
	}
	System.out.println("Happiness Changed");
}
----
There is a fair amount going on in this, so we'll parse it out piece by piece (for a more detailed techical
explanation, see [[fill in link]]).
First, note that there is a @Watch annotation before the method. This tells the Repast Simphony system
that this is going to be watching other objects in order to schedule the friendChanged() method. The first
parameter of the annotation is the watcheeClassName. This defines the type of agents that this object
will be watching. The second argument, watcheeFieldName, defines what field we are interested in monitoring. 
This means that there is a variable in the class SimpleHappyAgent, that we want to monitor
for changes. When it changes, this object will be notified. The query argument defines which instances
of SimpleHappyAgent we want to monitor. In this case we are monitoring agents to whom we are
linked. For more documentation on arguments for this query can be found at: Watcher Queries. The
whenToTrigger argument specifies whether to execute the action immediately (before the other actions at
this time are executed) or to wait until the next tick. The scheduleTriggerDelta defines how long to wait
before scheduling the action (in ticks). Finally the scheduleTriggerPriority allows you to help define the
order in which this action is executed at it's scheduled time.

Let me give a practical example of how this would be used. Let's say you are modelling electrical
networks. You may want to say that if a transformer shuts down, at some time in the future a plant will
shut down. So you make the plant a watcher of the transformer. The plant could watch a variable called
status on the transformers to which it is connected, and when the transformer's status changes to OFF,
then the plant can schedule to shut down in the future. All done with a single annotation. It could look
like this:

----
@Watch(watcheeClassName = "infr.Transformer", watcheeFieldName = "status", query =
	"linked_from", whenToTrigger = WatcherTriggerSchedule.LATER, scheduleTriggerDelta = 1)
public void shutDown(){
	operational = false;
}
----

Obviously that is a simple example, but it should give you an idea of how to work with scheduling this
way.

Watcher Queries
~~~~~~~~~~~~~~~
.TODO
****
Provide code examples
****

Watcher queries are boolean expressions that evaluate the watcher and the watchee with respect to each
other and some projection or context. The context is the context where the watcher resides and the
projections are those contained by that context. In the following "[arg]" indicates that the arg is optional.

* colocated - true if the watcher and the watchee are in the same context.
* linked_to ['network name'] - true if the watcher is linked to the watchee in any network, or
optionally in the named network
* linked_from ['network name'] - true if the watcher is linked from the watchee in any network, or
optionally in the named network
* within X ['network name'] - true if the path from the watcher to the watchee is less than or equal to
X where X is a double precision number. This is either for any network in the context or in the
named network.
* within_vn X ['grid name'] - true if the watchee is in the watcher's von neumann neighborhood in any
grid projection or in the named grid. X is the extent of the neighborhood in the x, y, [z] dimensions.
* within_moore X ['grid name'] - true if the watchee is in the watcher's moore neighborhood in any
grid projection or in the named grid. X is the extent of the neighborhood in the x, y, [z] dimensions.
* within X ['geography name'] true if the orthodromic distance from the watcher to the watchee is
less than or equal to X meters, otherwise false.
Watcher queries can be combined using the keywords not and and as well as ( to establish precedence.
For example

----
within 2 'family' and not linked_to 'business'
----

The queries are tested in WatcherQueryTests and defined as annotations in MyWatcher.

GUI Parameters and Probes
~~~~~~~~~~~~~~~~~~~~~~~~~

.TODO
****
- GUI Parameters and Probes (remove extended parameters bit, add the custom probe registration stuff and update the annotations that can be used on agent properties, e.g., the statecharts agent property annotation)
****

.GUI Parameters
GUI Parameters are the simulation parameters that appear in the parameters view in the application GUI.
These parameters are automatically created from the parameters XML file or from any
@Parameters method annotations that are used in a Context. At the moment, these two options only
allow for the creation of unconstrained numeric, boolean and String parameters. However, constrained
parameters of more complicated types can be defined using an xml based format. This section describes how 
to save, load and "set as default" parameters using the parameters tools menu, and the last section looks 
at the parameters returned from agent probes.

.Convertors and custom parameter types
Repast Simphony can internally handle the conversion of numeric and boolean types to and from the
Strings in the gui display and the parameter file. However, if you wish to use a type other than these,
then you must provide a converter that will convert an Object to and from a String representation. A
converter is class that implements StringConverter and is used to create the appropriate Object from a
string representation when reading the xml file and taking input from the gui. The converter also converts
the object to a string representation. This string is then used when writing the object out and displaying
the parameter's value in the gui.

For example, supposing you wish use the following Name class as a Parameter.

----
package repast.test.viz;public class Name {
	private String first, last;
	private int hashCode;
	
	public Name(String first, String last) {
		this.first = first;
		this.last = last;
		hashCode = 17;
		hashCode = 37 * hashCode + first.hashCode();
		hashCode = 37 * hashCode + last.hashCode();
	}

	public String getFirst() {
		return first;
	}

	public String getLast() {
		return last;
	}
	
	public int hashCode() {
		return hashCode;
	}

	public boolean equals(Object obj) {
		if (obj instanceof Name) {
			Name other = (Name) obj;
			return other.first.equals(this.first) && other.last.equals(this.last);
		}
		return false;
	}
	
	public String toString() {
		return "Name(" + first + ", " + last + ")";
	}
}
----

Your parameter XML then would look something like:
----
<parameters> ...
	<parameter name="name" displayName="Full Name" type="repast.test.viz.Name" 
		defaultValue="Joe Smith" converter="repast.test.viz.NameConverter" />
</parameters>
----

The type is the fully qualified name of the parameter type (in this case "Name") and the converter is the
fully qualified name of the converter class. The converter must implement the StringConverter interface.
StringConverter has two methods for converting to and from a String representation.

----
package repast.parameter;

/**
* Converts an Object to and from a String representation. Subclasses
* are specialized for specified objects.
*
* @author Nick Collier
*/
public interface StringConverter<T> {

	/**
	* Converts the specified object to a String representation and
	* returns that representation. The representation should be such
	* that <code>fromString</code> can recreate the Object.
	*
	* @param obj the Object to convert.
	*
	* @return a String representation of the Object.
	*/
	String toString(T obj);

	/**
	* Creates an Object from a String representation.
	*
	* @param strRep the string representation
	* @return the created Object.
	*/
	T fromString(String strRep);
}
----

The NameConverter then looks like:

----
package repast.test.viz;
import repast.parameter.*;
public class NameConverter implements StringConverter<Name> {

	/**
	* Converts the specified object to a String representation and
	* returns that representation. The representation should be such
	* that <code>fromString</code> can recreate the Object.
	*
	* @param obj the Object to convert.
	* @return a String representation of the Object.
	*/
	public String toString(Name obj) {
		return obj.getFirst() + " " + obj.getLast();
	}

	/**
	* Creates an Object from a String representation.
	*
	* @param strRep the string representation
	* @return the created Object.
	*/
	public Name fromString(String strRep) {
		int index = strRep.indexOf(" ");
		String first = strRep.substring(0, index);
		String last = strRep.substring(index + 1, strRep.length());
		return new Name(first, last);
	}
}
----

It is also possible to use the values attribute to constrain the possible values of a converted parameter.
For example:

----
<parameters> ...
	<parameter name="name" displayName="Full Name" type="repast.test.viz.Name" 
		defaultValue="Joe Smith" converter="repast.test.viz.NameConverter" 
		values="'Joe Smith' 'Mary Smith' 'Granny Smith'"/>
</parameters>
----

When constraining a converted parameter, the elements in the values list must be Strings that can be
converted using the converter. If you do constrain a converted parameter in this way, you must override
equals (and hashCode) in your custom type. If not, then the constraint validation will most likely fail.

.Parameters Panel Tools
The menu on the parameters panels allows the user to save and load parameter values, and set the
current parameter values as the default.

* Saving - clicking the save menu item will prompt for a file name and then save the current
parameter values into that file.

* Loading - clicking the load menu item will prompt for a file name and then load the parameter
values from that file into the current parameters. This assumes that the current parameters
are compatible with those being loaded, that is, that the names and types of parameters
in the file match the current parameters.

* Set as Default - this allows the user to set current parameter values as defaults such that these
values will be used when the simulation is reset. Clicking this menu item prompts for which
parameters to set as defaults and then sets those as the new defaults.

.Agent Probes
An agent can be probed by clicking on its visual representation in the gui. The agent's parameters will
then be displayed in a probe panel. By default, the displayed parameters are derived from an agent's
Java bean properties which are themselves derived from get / set accessor method pairs. For example,

----
public class VizAgent {
	...
	public double getWealth() {
		...
	}
	
	public void setWealth(double val) {
		...
	}
}
----

This creates a "wealth" parameter. The probe panel will display an entry for "wealth" whose value is the
result of the "getWealth" call. When the user enters a new value in the "wealth" text field then the
setWealth method will passed this new value. Read-only parameters can be created by specifying only a
get-style method. The label for this field will be the simple java bean properties name.
Which properties are treated as parameters, and how to display them can be further refined by adding an
@Parameter annotation to either the getter or setter of a property method pair. (The information in the
annotation applies equally to both methods.) Using a Parameter annotation, a more descriptive display
name can be specified. For example:

----
public class VizAgent {
	...
	@Parameter(usageName="wealth", displayName="Agent Wealth (in Euros)")
	public double getWealth() {
		...
	}
	
	public void setWealth(double val) {
		...
	}
}
----

The usageName should correspond to the java bean property which is typically the method name minus
the get/set with the first character lower-cased. The displayName specifies the gui label for this
parameter in the probe window.

NOTE: If any method is annotated with @Parameter, then only @Parameter annotated methods will
be displayed in the probe panel.

Using the @Parameter annotation, you can also specify the name of a converter to convert to and from a
displayable String. By specifying a converter, any type of object contained by the agent can be displayed
as a parameter. This converter is identical that described above in the extended parameters section. See
the convertors and custom parameter types section above for more details. For example,

----
public class VizAgent {
	...
	@Parameter(usageName="wealth", displayName="Agent Wealth (in Euros)",
		converter="repast.demo.MoneyConverter")
	public Money getWealth() {
		...
	}

	public void setWealth(Money val) {
		...
	}
}
----

In this case, the agent's wealth is represented by a Money class and a MoneyConverter is used to convert
to and from a String value.
Lastly, by default the probe's title will be the result of calling "toString()" on the probed object (e.g.
VizAgent@55927f, in the above screen shot). A more appropriate title can be specified either by
overriding toString() and returning the desired value, or annotating any method that returns the desired
title with @ProbeID. For example:

----
public class VizAgent {
	... 
	@ProbeID 
	public String name() { return name;}

	@Parameter(usageName="wealth", displayName="Agent Wealth (in Euros)",
		converter="repast.demo.MoneyConverter")
	public Money getWealth() {
		...
	}

	public void setWealth(Money val) {
		...
	}
}
----

Agent Adaptation
----------------

.TODO
****
Section should be reviewed to make sure the example code is up to date.
****

Batch Runs
----------

.TODO
****
Brief explanation or see Batch guide.
****

Batch Parameters
~~~~~~~~~~~~~~~~
.TODO
****
Needs updating. check if this is described in Batch Guide
****

Repast Simphony supports the creation of a parameter sweep through an xml file or through a scripted
bsf file. Both define a sweep through the defintion of parameter setters. These setters may be constant
setters such that the parameter value remains at its initial value, or the setters may define a list of values
to sweep through, or lastly the setter may function as a numeric stepper that incrementally steps from an
initial value through some ending value. These setters are organized in tree such that the sweep defined
by a child is fully iterated through before the parent is incremented.

.Parameter XML file
Individual parameters are identified as parameter elements and have two required attributes: name
and type.
----
<parameter name="parameter_1" type=["number", "list", "constant"] ... />
----

* name is the name of the parameter. The current value of the parameter can be retrieved from the
Parameters object using this name.

* type identifies the how the value of the parameter will be set over the course of subsequent batch
runs. Depending on the type, the parameter element will have additional attributes.

.Parameter Types
Currently 3 types of parameters are supported.

* number -- the number type defines a parameter space with a starting, ending and step value. The
sweep mechanism will sweep through the space defined by these values by incrementing the
starting value with the step value until the ending value is reached. For example,

----
<parameter name="num_1" type="number" start="1" end="4" step="1"/>
----

will start with a value of 1 and increment by 1 until 4 is reached. The type of number (long, double,
float and integer) is inferred from the start, end and step values. If any of the values ends with 'f',
for example

----
4f or 3.21f
----

the parameter will be of the float type. Similarly, if any of the values end with 'L', the type will be a
long. In the absence of a "f" suffix, if any of the numeric values contain a decimal point and one or
more digits (e.g. 4.0) then the type will be a double. Otherwise, the type will be int.

* list -- the list type defines a parameter space as a list.

----
<parameter name="list_val" type="list" value_type=["string", "boolean", "double", "int",
"long", "float"] values="x y z"/>
----

The sweeper will iterate through the values in the list setting the parameter to that value.The
value_type attribute defines the type of the list elements and can be one of string, boolean,
double, int, long, float. Elements are delimited by a blank space. String elements can be surrounded
by single quotes (') if they contain blank space. For example,

----
<parameter name="list_val" type="list" value_type="string" values="'foo bar' 'bar' 'baz'"/>
defines 3 elements foo bar, bar and baz.
----

* constant -- constant types define a parameter space consisting of a single constant value.

----
<parameter name="const_1" type="constant" constant_type=["number", "boolean", "string"]
value="x"/>
----

The sweeper will set the parameter to this constant value. The constant_type attribute defines the
type of the constant value. A constant type of "number" works as its does above where the specified
type of number (float and so forth) is derived from the value itself.

.Nesting Parameters
Parameters can be nested such that the space defined by the child or nested parameter will be swept
before incrementing any values in the parent parameter at which point the child will be reset to its
starting value. For example,

----
<parameter name="numAgents" type="number" start="1000" end="2000" step="10">
	<parameter name="wealth" type="list" value_type="float" values="10.1 12.3 1234.23 23" />
</parameter>
----
In this case, the sweeper will do set numAgents to 1000 and then sweep through each of the the wealth
values. Then it will increment numAgents to 1010, and sweep through all the wealth values. It will
continue in this fashion until numAgents reaches its end value. In this way, the simulation is run such
that all the combinations of numAgents and wealth values are explored.

.Random Seed Parameter
The default random seed (i.e. the seed for the default random stream) can be specified in a parameter
file using a number type parameter with a name of "randomSeed". For example,

----
<parameter name="randomSeed" type="number" start="1" end="4" step="1"/>
----

If no such parameter exists, the batch mechanism will set the random seed to the current time in
milliseconds. 

NOTE: This seed will then be used for all the batch runs, that is, each batch run
will use the same random seed.


Advanced Topics
---------------

Adding Controller Actions
~~~~~~~~~~~~~~~~~~~~~~~~~

Controller actions can be added and integrated into the controller tree via 
plugin extension points. The repast.simphony.core plugin defines the following:

----
<extension-point id="composite.action">
	<parameter-def id="creatorClass"/>
</extension-point>
<extension-point id="component.action">
	<parameter-def id="actionIO"/>
</extension-point>
----

* "composite.action" is used to create a parent controller action, that is, a controller action that is
composed of child controller actions. The value of the "creatorClass" parameter must be the name of
a class that implements the CompositeControllerActionCreator interface.

* "component.action" is used to create child or component controller actions that are leaves in the
controller action tree. The value of the "actionIO" parameter must the name of a class that
implements the ControllerActionIO interface. This class is primarily responsible for serializing and
deserializing (saving and loading) a specific type of controller action. For example, the
CNDataLoaderControllerActionIO class is responsible for serializing and deserializing the class name
data loader action.

The repast.simphony.gui plugin extends these two extension points with:
----
<extension-point id="composite.action" parent-plugin-id="repast.simphony.core" parent-point-id="composite.action">
	<parameter-def id="label"/>
</extension-point>
<extension-point id="component.action" parent-plugin-id="repast.simphony.core" parent-point-id="component.action">
	<parameter-def id="editorCreator"/>
	<parameter-def id="parentMenuItem" multiplicity="none-or-one"/>
	<parameter-def id="parentID"/>
</extension-point>
----

These extend the above by adding gui related parameters.
* composite.action adds a label parameter the value of which will be the label for the parent action as
it is displayed in the controller action tree.

* component.action adds 3 new parameters
. editorCreator. The value of this parameter is a class that implements the ActionEditorCreator
interface. The editor created by the class that implements this interface will be used to create a
gui editor for editing this action.

. parentMenuItem. The value of this parameter is a class that implements the EditorMenuItem.
This will create the item in the parent menu that allows actions of this type to be created.

. parentID. this is the id of the parent of this controller action.Default parent ids are defined in
repast.plugin.ControllerActionConstants:

----
String VIZ_ROOT = "repast.controller.action.viz";
String DATA_LOADER_ROOT = "repast.controller.action.data_loaders";
String SCHEDULE_ROOT = "repast.controller.action.schedule";
String OUTPUTTER_ROOT = "repast.controller.action.outputters";
String GRAPH_ROOT = "repast.controller.action.graphs";
String REPORT_ROOT = "repast.controller.action.reports";
String DATA_SET_ROOT = "repast.controller.action.data_sets";
----

All the controller actions in repast simphony are added via this mechanism so examining their plugin.xml
files and related code is a good place to learn more.

Genetic Algorithms
~~~~~~~~~~~~~~~~~~

Repast Simphony (Repast S) uses the Java Genetic Algorithms Package (JGAP) (http://jgap.sourceforge.net/) to implement genetic algorithms. JGAP can be used directly within agents or the Repast S genetic algorithms (GA) wrapper can be used. Directly using JGAP provides maximum flexibility but requires more complex programming. The Repast S GA wrapper simplifies the use of JGAP while preserving most options. It is recommended that Repast S users start with the Repast S wrapper and, only if needed, eventually move to directly use of JGAP. The Repast S regression wrapper is consistent with direct use of JGAP so this should relatively straightforward. Obviously, as with all machine learning tools, it is important to make sure that genetic algorithms, in general, and the chosen
formulation, in particular, are appropriate for your application.

TIP: Documentation on how to use JGAP directly can be found on their web site, http://jgap.sourceforge.net/ In particular, please see the following page: http://jgap.sourceforge.net/doc/tutorial.html

.To use the Repast S GA wrapper in the visual editor simply follow these steps:

* Add a property of type "Genetic Algorithm" to an agent. "evaluate" is the name of the fitness function
that needs to be created as described in step two. "populationSize" is the count of the members in the GA
population. The "Gene" array gives the set of genes, either "IntegerGene" or "DoubleGene," to be used.
The parameters to the constructors (e.g., "min1" and "max1") are the optional lower and upper bounds
for that gene. The template is as follows:

----
new RepastGA(this, "evaluate", populationSize, 
	new Gene[]{ new IntegerGene(min1, max1) new DoubleGene(min2, max2)})
----

* Add a behavior that takes a double precision array (i.e., "double[]"), returns an positive integer
result, and that uses the fitness function name given above (e.g., "evaluate"). The double array is the
current population member to be evaluated. The genes are in the same order as the template given in
step one. Higher fitness result values mean greater fitness levels. The exact range does not matter as
long as the numbers are positive.

* Using the Wizard dialog, chose "Advanced Adaptation," "Use a Genetic Algorithm," "Get the Best
Solution from a Genetic Algorithm," and then fill in the form to get a solution. The returned double array
is the current best solution. The genes are in the same order as the template given in step one.

* If the population needs to be reset, perhaps due to a plateau, using the Wizard dialog, chose
"Advanced Adaptation," "Use a Genetic Algorithm," "Reset the Population of a Genetic Algorithm," and
then fill in the form.

.To use the Repast S GA wrapper in the Java or Groovy simply follow these steps:

* Add an agent class field of type RepastGA and create an instance following this template:

----
new RepastGA(this, "evaluate", populationSize, 
	new Gene[]{ new IntegerGene(min1, max1) new DoubleGene(min2, max2)})
----

"evaluate" is the name of the fitness function that needs to be created as described in step two.
"populationSize" is the count of the members in the GA population. The "Gene" array gives the set of
genes, either "IntegerGene" or "DoubleGene," to be used. The parameters to the constructors (e.g.,
"min1" and "max1") are the optional lower and upper bounds for that gene.

* Add a class method behavior that takes a double precision array (i.e., "double[]"), returns an positive
integer result, and that uses the fitness function name given above (e.g., "evaluate"). The double array is
the current population member to be evaluated. The genes are in the same order as the template given
in step one. Higher fitness result values mean greater fitness levels. The exact range does not matter as
long as the numbers are positive. For higher performance, advanced users can implement
org.jgap.FitnessFunction in place of just the creating the simple "int evaluate(double[])" method.

* Use the following method template to get a solution:

----
double[] solution = model.getBestSolution(cycles)
----

"cycles" is the number of evolutionary steps to use to compute the requested solution. The returned
double array is the current best solution. The genes are in the same order as the template given in step
one.

* If the population needs to be reset, use the following method template:
----
model.reset()
----

Neural Networks
~~~~~~~~~~~~~~~

Repast Simphony (Repast S) uses the Java Object Oriented Neural Engine (Joone)
(http://www.jooneworld.com/) library to implement neural networks. Joone can be used directly within
agents or the Repast S neural network wrapper can be used. Directly using Joone provides maximum
flexibility but requires more complex programming. The Repast S wrapper simplifies the use of Joone
while preserving most options. It is recommended that Repast S users start with the Repast S wrapper
and, only if needed, eventually move to directly use of Joone. The Repast S wrapper is consistent with
direct use of Joone so this should relatively straightforward. Obviously, as with all machine learning tools,
it is important to make sure that neural networks, in general, and the chosen network design, in
particular, are appropriate for your application.

TIP: Documentation on how to use Joone directly can be found on their web site, http://www.jooneworld.com/

.To use the Repast S neural network wrapper in the visual editor simply follow these steps:

* Add a property of type "Linear Neural Network," "Logistic Neural Network," or "Softmax Neural
Network" to an agent to produce the corresponding type of neural network. Replace the integer (i.e., int)
array elements with a description of the layers for your application. The first number in the array is the
count of input neurons, the last number is the count of output neurons, and the intermediate numbers
are the interstitial layers. You can have as many interstitial layers as you would like (i.e., zero or more).

* Using the Wizard dialog, chose "Advanced Adaptation," "Use a Neural Network," "Train a Neural
Network Model," and then fill in the form to store data for fitting. The input data array is indexed by the
number of training examples and the number of input neurons. The output data array is indexed by the
number of training examples and the number of output neurons.

* Using the Wizard dialog, chose "Advanced Adaptation," "Use a Neural Network," "Forecast from a
Neural Network," and then fill in the form to get a forecast. The input data array is indexed by the
number of input neurons. The output data array is indexed by the number of output neurons.
To use the Repast S regression wrapper in the Java or Groovy simply follow these steps:

* Add an agent class field of type NeuralNet and create an linear, logistic, or softmax instance as
follows:
----
JooneTools.create_standard(new int[]{inputNeurons intermediateLayer1 intermediateLayer2
intermediateLayerN outputNeurons}, JooneTools.LINEAR)).

JooneTools.create_standard(new int[]{inputNeurons intermediateLayer1 intermediateLayer2
intermediateLayerN outputNeurons}, JooneTools.LOGISTIC)).

JooneTools.create_standard(new int[]{inputNeurons intermediateLayer1 intermediateLayer2
intermediateLayerN outputNeurons}, JooneTools. SOFTMAX)).
----
* Use the following method to store data for fitting where "model" is the new field name: 
----
JooneTools.train(model, inputDataArray, targetOutputDataArray, epochs, convergenceLimit, 0, null);
----

The input data array is indexed by the number of training examples and the number of input neurons.
The output data array is indexed by the number of training examples and the number of output neurons.
The model will be trained until "epochs" cycles are completed or the "convergenceLimit" of root mean
square error is achieved, whichever comes first.

* Use the following method to get a forecast where "model" is the new field name:
----
double outputData[] = JooneTools.interrogate(model, inputData)
----
The input data array is indexed by the number of input neurons. The output data array is indexed by the
number of output neurons.

Regression
~~~~~~~~~~

Repast Simphony (Repast S) uses the OpenForecast (http://openforecast.sourceforge.net/) library to
implement regression. OpenForecast can be used directly within agents or the Repast S regression
wrapper can be used. Directly using OpenForecast provides maximum flexibility but requires more
complex programming. The Repast S regression wrapper simplifies the use of OpenForecast while
preserving most options. It is recommended that Repast S users start with the Repast S wrapper and,
only if needed, eventually move to directly use of OpenForecast. The Repast S regression wrapper is
consistent with direct use of OpenForecast so this should relatively straightforward. Obviously, as with all
statistical tools, it is important to make sure that regression, in general, and the chosen regression fit, in
particular, are appropriate for your application. The method "getForecastType()" can be used to find a
text description of the selected equation for both types of regression. It is recommended that this be
checked for appropriateness.

TIP: Documentation on how to use OpenForecast directly can be found on their web site,
http://openforecast.sourceforge.net/

.To use the Repast S regression wrapper in the visual editor simply follow these steps:

* Add a property of type "Multilinear Regression Model" or "Best Fit Regression Model" to an agent
"Multilinear Regression Model" always fits input data sets using a linear equation for one input variable or
multilinear equation for multiple input variables. "Best Fit Regression Model" causes OpenForecast to
consider a range of different equation families and then find the best fitting member of the best fitting
equation family. This includes linear and multilinear equations as well as other families as defined in the
OpenForecast documentation.

* Using the Wizard dialog, chose "Advanced Adaptation," "Use a Regression Model," "Store Data for a
Regression Model," and then fill in the form to store data for fitting.

* Using the Wizard dialog, chose "Advanced Adaptation," "Use a Regression Model," "Forecast from a
Regression Model," and then fill in the form to get a forecast. Please note that it generally is necessary to
return default forecasts for several steps before enough example data is available for a good quality
forecast.

.To use the Repast S regression wrapper in the Java or Groovy simply follow these steps:

* Add an agent class field of type RepastRegressionModel and create an instance (i.e., new
RepastRegressionModel(false)). Set the constructor parameter to "false" for "Multilinear Regression
Model" or "true" for "Best Fit Regression Model." "Multilinear Regression Model" always fits input data sets
using a linear equation for one input variable or multilinear equation for multiple input variables. "Best Fit
Regression Model" causes OpenForecast to consider a range of different equation families and then find
the best fitting member of the best fitting equation family. This includes linear and multilinear equations
as well as other families as defined in the OpenForecast documentation. Obviously, as with all statistical
tools, it is important to make sure that the chosen functions, both multilinear and best fit, are appropriate
for your application. The method "getForecastType()" can be used to find a text description of the
selected equation for both types of regression. It is recommended that this be checked for
appropriateness.

* Use the new field's "add(...) method to store data for fitting (i.e., model.add(y, x1, x2, x3)).

* Use the new field's "forecast(...)" method to get a forecast (i.e., double x = model.forecast(y1, y2,
y3)). Please note that it generally is necessary to return default forecasts for several steps before enough
example data is available for a good quality forecast.

