== Scheduling
There are basically three ways to work with the Repast Simphony Scheduler. No 
one is better than the other and they each have their specified purpose.

=== Directly Schedule an action
This is similar to the way that actions have always been scheduled in repast 
with a slight twist. In this scenario, you get a schedule and tell it the when 
and what to run. An example of adding an item to the schedule this way is as 
follows:

----
//Specify that the action should start at tick 1 and execute every other tick
ScheduleParameters params = ScheduleParameters.createRepeating(1, 2);

//Schedule my agent to execute the move method given the specified schedule parameters.
schedule.schedule(params, myAgent, "move");
----

The biggest change here is that instead of using one of the numerous methods to 
set up the parameters for the action like you would in repast 3, you just use 
an instance of ScheduleParameters. ScheduleParameters can be created using one 
of several convient factory methods if desired. A slight alteration of this is:

----
//Specify that the action should start at tick 1 and execute every other tick
ScheduleParameters params = ScheduleParameters.createRepeating(1, 2);

//Schedule my agent to execute the move method given the specified schedule parameters.
schedule.schedule(params, myAgent, "move", "Forward", 4);
----

This example schedules the same action with the same parameters, but passes 
arguments to the method that is to be called. The "Forward" and 4 will be passed 
as arguments to the method move. The assumption is that the signature for move 
looks like this:

----
public void move(String direction, int distance)
----

=== Schedule with Annotations
Java 5 introduced several new and exciting features (some of which are used 
above), but one of the most useful is Annotation support. Annotations, in java, 
are bits of metadata which can be attached to classes, methods or fields that 
are available at runtime to give the system more information. Notable uses 
outside repast includes the EJB3 spec which allows you to create ejbs using 
annotations without requiring such complex descriptors. For repast, we thought 
annotations were a perfect match for tying certain types of scheduling 
information to the methods that should be scheduled. The typical case where you 
would use annotations is where you have actions whose schedule is know at 
compile time. So for example, if you know that you want to have the paper 
delivered every morning, it would be logical to schedule the deliverPaper() 
method using annotations. Without going into extensive documentation about how 
annotations work (if you want that look at Java 5 Annotations), here is how you 
would schedule an action using annotations:

----
@ScheduledMethod(start=1 , interval=2)
public void deliverPaper()
----

The arguments of the annotation are similar to the properties for the 
ScheduleParameters object. One particularly nice feature of using annotations 
for scheduling is that you get keep the schedule information right next to the 
method that is scheduled, so it is easy to keep track of what is executing when. 
Most of the time, objects with annotations will automatically be added to the 
schedule, however, if you create a new object while your simulation is running, 
this may not be the case. Fortunately, the schedule object makes it very easy to 
schedule objects with annoations.

----
//Add the annotated methods from the agent to the schedule.
schedule.schedule(myAgent);
----

The schedule will search the object for any methods which have annotations and 
add those methods to the schedule. This type of scheduling is not designed to 
handle dynamic scheduling, but only scheduling, where the actions are well 
defined at compile time.

=== Schedule with Watcher
Scheduling using watchers is the most radical of the new scheduling approaches. 
Watchers are designed to be used for dynamic scheduling where a typical workflow 
is well understood by the model designer. Basically, a watcher allows an agent 
to be notified of a state change in another agent and schedule an event to occur 
as a result. The watcher is set up using an annotation (like above), but instead 
of using static times for the schedule parameters, the user specifies a query 
defining whom to watch and a query defining a trigger condition that must be met 
to execute the action. That's a bit of a mouthfull, so let's take a look at an 
example to hopefully clarify how this works. (this code is from the 
SimpleHappyAgent model which ships with Repast Simphony)

----
@Watch(watcheeClassName = "repast.demo.simple.SimpleHappyAgent", 
	watcheeFieldName = "happiness", query = "linked_from",
	whenToTrigger = WatcherTriggerSchedule.LATER, scheduleTriggerDelta = 1,
	scheduleTriggerPriority = 0)
public void friendChanged(SimpleHappyAgent friend) {
	if (Math.random() > .25) {
	this.setHappiness(friend.getHappiness());
	} else {
		this.setHappiness(Random.uniform.nextDouble());
	}
	System.out.println("Happiness Changed");
}
----

There is a fair amount going on in this, so we'll parse it out piece by piece. 
First, note that there is a @Watch annotation before the method. This tells the 
Repast Simphony system that this is going to be watching other objects in order 
to schedule the friendChanged() method. The first parameter of the annotation is 
the watcheeClassName. This defines the type of agents that this object will be 
watching. The second argument, watcheeFieldName, defines what field we are 
interested in monitoring. This means that there is a variable in the class 
SimpleHappyAgent, that we want to monitor for changes. When it changes, this 
object will be notified. The query argument defines which instances of 
SimpleHappyAgent we want to monitor. In this case we are monitoring agents to 
whom we are linked. For more documentation on arguments for this query can be 
found at: Watcher Queries. The whenToTrigger argument specifies whether to 
execute the action immediately (before the other actions at this time are 
executed) or to wait until the next tick. The scheduleTriggerDelta defines how 
long to wait before scheduling the action (in ticks). Finally the 
scheduleTriggerPriority allows you to help define the order in which this action 
is executed at it's scheduled time.

Let me give a practical example of how this would be used. Let's say you are 
modelling electrical networks. You may want to say that if a transformer shuts 
down, at some time in the future a plant will shut down. So you make the plant a 
watcher of the transformer. The plant could watch a variable called status on 
the transformers to which it is connected, and when the transformer's status 
changes to OFF, then the plant can schedule to shut down in the future. All done 
with a single annotation. It could look like this:

----
@Watch(watcheeClassName = "infr.Transformer", watcheeFieldName = "status", query =
	"linked_from", whenToTrigger = WatcherTriggerSchedule.LATER, scheduleTriggerDelta = 1)
public void shutDown(){
	operational = false;
}
----

Obviously that is a simple example, but it should give you an idea of how to 
work with scheduling this way.

=== Watcher Queries

// TODO Provide code examples

Watcher queries are boolean expressions that evaluate the watcher and the 
watchee with respect to each other and some projection or context. The context 
is the context where the watcher resides and the projections are those contained 
by that context. In the following "[arg]" indicates that the arg is optional.

* colocated - true if the watcher and the watchee are in the same context.

* linked_to ['network name'] - true if the watcher is linked to the watchee in 
any network, or optionally in the named network

* linked_from ['network name'] - true if the watcher is linked from the watchee 
in any network, or optionally in the named network

* within X ['network name'] - true if the path from the watcher to the watchee 
is less than or equal to X where X is a double precision number. This is either 
for any network in the context or in the named network.

* within_vn X ['grid name'] - true if the watchee is in the watcher's von 
neumann neighborhood in any grid projection or in the named grid. X is the 
extent of the neighborhood in the x, y, [z] dimensions.

* within_moore X ['grid name'] - true if the watchee is in the watcher's moore 
neighborhood in any grid projection or in the named grid. X is the extent of the 
neighborhood in the x, y, [z] dimensions.

* within X ['geography name'] true if the orthodromic distance from the watcher 
to the watchee is less than or equal to X meters, otherwise false. Watcher 
queries can be combined using the keywords not and and as well as ( to establish 
precedence. For example

----
within 2 'family' and not linked_to 'business'
----

The queries are tested in WatcherQueryTests and defined as annotations in 
MyWatcher.